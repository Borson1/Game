import React, { useState, useEffect, useRef, useCallback } from 'react';
import { 
  Play, RotateCcw, ShoppingBag, ArrowLeft, Coins, Heart, 
  Trophy, Pause, X, Rocket, AlertTriangle, Box, Volume2, VolumeX, Sparkles, Zap, ShieldCheck
} from 'lucide-react';
import { initializeApp } from 'firebase/app';
import { getAuth, signInWithCustomToken, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
import { getFirestore, doc, setDoc, onSnapshot } from 'firebase/firestore';

/**
 * COSMIC GUARDIAN: FIXED EDITION
 * - Fixed: Added missing 'bossActive' state which was causing the White Screen crash.
 * - Optimized: Better error handling for startup.
 */

// --- Safe Configuration & Firebase Initialization ---
let db = null;
let auth = null;
const APP_ID = typeof __app_id !== 'undefined' ? __app_id : 'cosmic-bulletproof-v9';

try {
  if (typeof __firebase_config !== 'undefined' && __firebase_config) {
    const firebaseConfig = JSON.parse(__firebase_config);
    const app = initializeApp(firebaseConfig);
    auth = getAuth(app);
    db = getFirestore(app);
  }
} catch (e) {
  console.error("Firebase startup failed. Running in Local-Only mode.");
}

// --- Ship Database ---
const SHIPS = [
  { id: 0, name: 'Alpha Scout', color: '#0ea5e9', price: 0, speed: 5, power: 10, desc: 'Balanced starter ship.' },
  { id: 1, name: 'Crimson Fury', color: '#f43f5e', price: 800, speed: 6, power: 18, desc: 'High damage output.' },
  { id: 2, name: 'Phantom Ray', color: '#a855f7', price: 2000, speed: 8, power: 25, desc: 'Stealth & Speed.' },
  { id: 3, name: 'Titan X', color: '#10b981', price: 4000, speed: 4, power: 45, desc: 'Ultimate Boss Killer.' },
];

const App = () => {
  // --- UI States ---
  const [view, setView] = useState('HOME');
  const [user, setUser] = useState(null);
  const [score, setScore] = useState(0);
  const [lives, setLives] = useState(3);
  const [isPaused, setIsPaused] = useState(false);
  const [level, setLevel] = useState(1);
  const [combo, setCombo] = useState(0);
  const [showWarning, setShowWarning] = useState(false);
  const [soundEnabled, setSoundEnabled] = useState(true);
  
  // --- FIXED: Missing State Added ---
  const [bossActive, setBossActive] = useState(false); 
  
  // --- Persistent Stats ---
  const [highScore, setHighScore] = useState(0);
  const [coins, setCoins] = useState(0);
  const [crates, setCrates] = useState(0);
  const [unlockedShips, setUnlockedShips] = useState([0]);
  const [selectedShipIndex, setSelectedShipIndex] = useState(0);

  const canvasRef = useRef(null);
  const requestRef = useRef(null);
  const audioCtx = useRef(null);

  // --- Mutable Game State (The Engine) ---
  const gameRef = useRef({
    player: { x: 0, y: 0, radius: 15, shield: 0, doubleFire: 0 },
    bullets: [], enemyBullets: [], enemies: [], powerups: [],
    particles: [], floatingTexts: [], shockwaves: [],
    stars: [], nebulas: [], boss: null, nextBossScore: 2000,
    keys: {}, touchPos: null, frameCount: 0,
    isWarping: false, warpTimer: 0, comboTimer: 0
  });

  // --- Helper: Safe Storage ---
  const saveStats = useCallback((data) => {
    try {
      const local = JSON.parse(localStorage.getItem('cosmic_v9_save') || '{}');
      const merged = { ...local, ...data };
      localStorage.setItem('cosmic_v9_save', JSON.stringify(merged));
      
      if (user && db) {
        setDoc(doc(db, 'artifacts', APP_ID, 'users', user.uid, 'data', 'profile'), merged, { merge: true });
      }
    } catch (e) {
      console.error("Save failed", e);
    }
  }, [user]);

  // --- Initialize Auth & Data ---
  useEffect(() => {
    // Load from LocalStorage immediately to avoid white screen delay
    try {
      const saved = JSON.parse(localStorage.getItem('cosmic_v9_save') || '{}');
      if (saved.highScore) setHighScore(saved.highScore);
      if (saved.coins) setCoins(saved.coins);
      if (saved.crates) setCrates(saved.crates);
      if (saved.unlockedShips) setUnlockedShips(saved.unlockedShips);
      if (saved.selectedShipIndex) setSelectedShipIndex(saved.selectedShipIndex);
    } catch (e) {}

    if (auth) {
      const initAuth = async () => {
        try {
          if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
            await signInWithCustomToken(auth, __initial_auth_token);
          } else {
            await signInAnonymously(auth);
          }
        } catch (e) {}
      };
      initAuth();
      return onAuthStateChanged(auth, (u) => {
        setUser(u);
        if (u && db) {
          const unsub = onSnapshot(doc(db, 'artifacts', APP_ID, 'users', u.uid, 'data', 'profile'), (snap) => {
            if (snap.exists()) {
              const d = snap.data();
              setHighScore(d.highScore || 0);
              setCoins(d.coins || 0);
              setCrates(d.crates || 0);
              setUnlockedShips(d.unlockedShips || [0]);
            }
          });
          return unsub;
        }
      });
    }
  }, []);

  // --- Sound Engine ---
  const playSfx = useCallback((type) => {
    if (!soundEnabled) return;
    try {
      if (!audioCtx.current) audioCtx.current = new (window.AudioContext || window.webkitAudioContext)();
      const ctx = audioCtx.current;
      if (ctx.state === 'suspended') ctx.resume();
      
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain); gain.connect(ctx.destination);
      const now = ctx.currentTime;

      if (type === 'shoot') {
        osc.frequency.setValueAtTime(400, now); osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.05, now); osc.start(); osc.stop(now + 0.1);
      } else if (type === 'explosion') {
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now); gain.gain.setValueAtTime(0.1, now); 
        osc.start(); osc.stop(now + 0.2);
      } else if (type === 'coin') {
        osc.frequency.setValueAtTime(1000, now); gain.gain.setValueAtTime(0.05, now); 
        osc.start(); osc.stop(now + 0.1);
      }
    } catch (e) {}
  }, [soundEnabled]);

  // --- VFX Logic ---
  const spawnExplosion = (x, y, color) => {
    for (let i = 0; i < 12; i++) {
      gameRef.current.particles.push({
        x, y, vx: (Math.random() - 0.5) * 8, vy: (Math.random() - 0.5) * 8,
        life: 1.0, color, size: Math.random() * 3 + 2
      });
    }
  };

  const spawnText = (x, y, text, color, size = 12) => {
    gameRef.current.floatingTexts.push({ x, y, text, color, life: 1.0, dy: -1.5, size });
  };

  // --- Game Loop ---
  const startMission = () => {
    const w = window.innerWidth;
    const h = window.innerHeight;
    if (canvasRef.current) {
      canvasRef.current.width = w;
      canvasRef.current.height = h;
    }
    const ship = SHIPS[selectedShipIndex] || SHIPS[0];
    
    gameRef.current = {
      ...gameRef.current,
      width: w, height: h,
      player: { x: w / 2, y: h - 100, radius: 15, color: ship.color, speed: ship.speed, power: ship.power, shield: 0, doubleFire: 0 },
      bullets: [], enemyBullets: [], enemies: [], powerups: [], floatingTexts: [], particles: [], shockwaves: [],
      boss: null, nextBossScore: 2000, isWarping: false, warpTimer: 0, comboTimer: 0, frameCount: 0,
      stars: Array.from({ length: 60 }, () => ({ x: Math.random() * w, y: Math.random() * h, s: Math.random() * 2, alpha: Math.random() })),
      nebulas: Array.from({ length: 4 }, () => ({ x: Math.random() * w, y: Math.random() * h, r: 200, color: 'rgba(56, 189, 248, 0.08)', vx: (Math.random() - 0.5) * 0.3, vy: (Math.random() - 0.5) * 0.3 })),
    };
    
    setScore(0); setLives(3); setLevel(1); setCombo(0); setBossActive(false); setShowWarning(false);
    setIsPaused(false); setView('PLAYING');
  };

  const loop = () => {
    if (view !== 'PLAYING' || isPaused || !canvasRef.current) return;
    const ctx = canvasRef.current.getContext('2d');
    const g = gameRef.current;
    const p = g.player;

    // Background
    ctx.fillStyle = '#020617'; ctx.fillRect(0, 0, g.width, g.height);

    // Nebulas
    g.nebulas.forEach(n => {
      n.x += n.vx; n.y += n.vy;
      if (n.x < 0 || n.x > g.width) n.vx *= -1; if (n.y < 0 || n.y > g.height) n.vy *= -1;
      const grad = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
      grad.addColorStop(0, n.color); grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2); ctx.fill();
    });

    // Stars
    g.stars.forEach(s => {
      s.y += g.isWarping ? 35 : 0.6;
      if (s.y > g.height) { s.y = 0; s.x = Math.random() * g.width; }
      ctx.fillStyle = `rgba(255,255,255,${g.isWarping ? 1.0 : s.alpha})`;
      ctx.beginPath();
      if (g.isWarping) ctx.rect(s.x, s.y - 40, 2, 40); else ctx.arc(s.x, s.y, s.s, 0, Math.PI * 2);
      ctx.fill();
    });

    if (g.isWarping) {
      g.warpTimer--;
      if (g.warpTimer <= 0) { g.isWarping = false; setLevel(l => l + 1); spawnText(g.width / 2, g.height / 2, `LEVEL ${level + 1}`, '#38bdf8', 35); }
      p.x += (g.width / 2 - p.x) * 0.1;
      requestRef.current = requestAnimationFrame(loop);
      return;
    }

    // Controls
    if (g.touchPos) { p.x += (g.touchPos.x - p.x) * 0.15; p.y += (g.touchPos.y - 70 - p.y) * 0.15; }
    p.x = Math.max(20, Math.min(g.width - 20, p.x));
    p.y = Math.max(20, Math.min(g.height - 20, p.y));

    // Player Ship
    ctx.save(); ctx.translate(p.x, p.y);
    if (p.shield > 0) { p.shield--; ctx.strokeStyle = '#38bdf8'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(0, 0, 28, 0, Math.PI * 2); ctx.stroke(); }
    ctx.shadowBlur = 15; ctx.shadowColor = p.color; ctx.fillStyle = p.color;
    ctx.beginPath(); ctx.moveTo(0, -22); ctx.lineTo(-18, 14); ctx.lineTo(0, 8); ctx.lineTo(18, 14); ctx.fill();
    ctx.fillStyle = '#f97316'; ctx.beginPath(); ctx.moveTo(-6, 10); ctx.lineTo(0, 10 + Math.random() * 15 + 5); ctx.lineTo(6, 10); ctx.fill();
    ctx.restore();

    // Bullets
    if (p.doubleFire > 0) p.doubleFire--;
    g.frameCount++;
    if (g.frameCount % 18 === 0) {
      playSfx('shoot');
      if (p.doubleFire > 0) {
        g.bullets.push({ x: p.x - 12, y: p.y - 12, c: '#60a5fa', w: 4, h: 12 });
        g.bullets.push({ x: p.x + 12, y: p.y - 12, c: '#60a5fa', w: 4, h: 12 });
      } else {
        g.bullets.push({ x: p.x, y: p.y - 18, c: p.color, w: 5, h: 18 });
      }
    }
    for (let i = g.bullets.length - 1; i >= 0; i--) {
      let b = g.bullets[i]; b.y -= 12;
      ctx.fillStyle = b.c; ctx.fillRect(b.x - b.w / 2, b.y, b.w, b.h);
      if (b.y < -30) g.bullets.splice(i, 1);
    }

    // Boss Warning & Logic
    if (score >= g.nextBossScore && !g.boss && !showWarning) {
      setShowWarning(true); playSfx('warn');
      g.enemies.forEach(e => spawnExplosion(e.x, e.y, e.color)); g.enemies = [];
      setTimeout(() => {
        setShowWarning(false); setBossActive(true);
        const hp = 1500 * Math.pow(1.3, level);
        g.boss = { x: g.width / 2, y: -150, hp, maxHp: hp, dir: 1, timer: 0 };
      }, 3500);
    }
    if (g.boss) {
      const b = g.boss; b.timer++; b.y = Math.min(b.y + 0.6, 130); b.x += b.dir * 1.8;
      if (b.x > g.width - 80 || b.x < 80) b.dir *= -1;
      
      if (g.frameCount % 50 === 0) {
        g.enemyBullets.push({ x: b.x, y: b.y + 50, dx: 0, dy: 6 });
        g.enemyBullets.push({ x: b.x - 30, y: b.y + 40, dx: -1.5, dy: 5 });
        g.enemyBullets.push({ x: b.x + 30, y: b.y + 40, dx: 1.5, dy: 5 });
      }

      g.bullets.forEach((bull, bi) => {
        if (Math.abs(bull.x - b.x) < 70 && Math.abs(bull.y - b.y) < 60) {
          b.hp -= p.power; spawnText(b.x + (Math.random() - 0.5) * 50, b.y, `-${p.power}`, '#fbbf24', 12);
          g.bullets.splice(bi, 1); spawnExplosion(bull.x, bull.y, '#fbbf24');
          if (b.hp <= 0) {
            playSfx('explosion'); spawnExplosion(b.x, b.y, '#ef4444');
            setScore(s => s + 4000); g.nextBossScore += 5000;
            g.boss = null; setBossActive(false); g.isWarping = true; g.warpTimer = 120;
            g.powerups.push({ x: b.x, y: b.y, type: 'B' }); g.powerups.push({ x: b.x + 30, y: b.y, type: 'S' });
          }
        }
      });

      ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.moveTo(b.x-60, b.y-30); ctx.lineTo(b.x+60, b.y-30); ctx.lineTo(b.x+40, b.y+40); ctx.lineTo(b.x-40, b.y+40); ctx.fill();
      ctx.fillStyle = '#333'; ctx.fillRect(b.x-60, b.y-70, 120, 8);
      ctx.fillStyle = '#ef4444'; ctx.fillRect(b.x-60, b.y-70, (b.hp/b.maxHp)*120, 8);
    }

    // Enemies
    const sRate = Math.max(30, 95 - level * 5);
    if (!g.boss && !showWarning && g.frameCount % sRate === 0) {
      const homing = Math.random() > 0.82;
      g.enemies.push({
        x: Math.random() * (g.width - 50) + 25, y: -60,
        r: homing ? 15 : 18 + Math.random() * 8,
        hp: homing ? 45 : 18 + level * 6,
        type: homing ? 'HOMING' : 'NORMAL',
        speed: homing ? 2.6 : 1.8 + level * 0.12,
        color: homing ? '#ef4444' : '#64748b'
      });
    }

    if (g.comboTimer > 0) { g.comboTimer--; if (g.comboTimer === 0) setCombo(0); }
    for (let i = g.enemies.length - 1; i >= 0; i--) {
      let e = g.enemies[i];
      if (e.type === 'HOMING') {
        let ang = Math.atan2(p.y - e.y, p.x - e.x);
        e.x += Math.cos(ang) * e.speed; e.y += Math.sin(ang) * e.speed;
        ctx.strokeStyle = 'rgba(239,68,68,0.3)'; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(e.x, e.y); ctx.lineTo(p.x, p.y); ctx.stroke();
      } else e.y += e.speed;

      ctx.fillStyle = e.color; ctx.beginPath(); ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2); ctx.fill();

      // Hit Player
      if (Math.hypot(p.x - e.x, p.y - e.y) < e.r + p.radius) {
        if (p.shield > 0) { spawnExplosion(e.x, e.y, e.color); g.enemies.splice(i, 1); spawnText(e.x, e.y, "BLOCKED", '#38bdf8'); }
        else {
          spawnExplosion(p.x, p.y, '#ef4444'); g.enemies.splice(i, 1); setCombo(0);
          setLives(l => { 
            if (l - 1 <= 0) { setView('GAME_OVER'); saveStats({ crates: crates + 1, highScore: Math.max(highScore, score) }); setCrates(c => c + 1); }
            return l - 1;
          });
          playSfx('explosion'); spawnText(p.x, p.y, "CRITICAL!", '#ef4444');
        }
      }

      // Hit Enemy
      for (let j = g.bullets.length - 1; j >= 0; j--) {
        let b = g.bullets[j];
        if (Math.hypot(b.x - e.x, b.y - e.y) < e.r + 5) {
          e.hp -= p.power; g.bullets.splice(j, 1); spawnExplosion(b.x, b.y, '#fff');
          if (e.hp <= 0) {
            playSfx('explosion'); spawnExplosion(e.x, e.y, e.color);
            setCombo(c => { g.comboTimer = 180; return c + 1; });
            let pts = Math.floor((e.type === 'HOMING' ? 180 : 100) * (1 + combo * 0.1));
            setScore(s => s + pts); spawnText(e.x, e.y, `+${pts}`, '#fbbf24', 14);
            g.enemies.splice(i, 1);
            if (Math.random() < 0.12) g.powerups.push({ x: e.x, y: e.y, type: 'COIN' });
            else if (Math.random() < 0.08) g.powerups.push({ x: e.x, y: e.y, type: Math.random() > 0.5 ? 'B' : 'S' });
            break;
          }
        }
      }
      if (e.y > g.height + 50) g.enemies.splice(i, 1);
    }

    // Powerups
    for (let i = g.powerups.length - 1; i >= 0; i--) {
      let pu = g.powerups[i]; pu.y += 2.5;
      ctx.fillStyle = pu.type === 'COIN' ? '#fbbf24' : (pu.type === 'B' ? '#3b82f6' : '#10b981');
      ctx.beginPath(); ctx.arc(pu.x, pu.y, 14, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = 'black'; ctx.font = 'bold 12px sans-serif'; ctx.textAlign = 'center'; ctx.fillText(pu.type === 'COIN' ? '$' : pu.type, pu.x, pu.y + 5);
      if (Math.hypot(p.x - pu.x, p.y - pu.y) < 30) {
        if (pu.type === 'COIN') { playSfx('coin'); setCoins(c => { const n = c + 1; saveStats({ coins: n }); return n; }); spawnText(p.x, p.y - 30, "+1 CREDIT", '#fbbf24'); }
        else if (pu.type === 'B') { p.doubleFire = 1000; spawnText(p.x, p.y - 30, "DUAL FIRE", '#3b82f6'); }
        else { p.shield = 1000; spawnText(p.x, p.y - 30, "SHIELD UP", '#10b981'); }
        g.powerups.splice(i, 1);
      }
    }

    // VFX Cleanup
    for (let i = g.particles.length - 1; i >= 0; i--) { let pt = g.particles[i]; pt.x += pt.vx; pt.y += pt.vy; pt.life -= 0.06; if (pt.life <= 0) g.particles.splice(i, 1); else { ctx.globalAlpha = pt.life; ctx.fillStyle = pt.color; ctx.beginPath(); ctx.arc(pt.x, pt.y, pt.size, 0, Math.PI * 2); ctx.fill(); ctx.globalAlpha = 1; } }
    for (let i = g.floatingTexts.length - 1; i >= 0; i--) { let ft = g.floatingTexts[i]; ft.y += ft.dy; ft.life -= 0.025; ctx.globalAlpha = ft.life; ctx.fillStyle = ft.color; ctx.font = `bold ${ft.size}px monospace`; ctx.textAlign = 'center'; ctx.fillText(ft.text, ft.x, ft.y); ctx.globalAlpha = 1; if (ft.life <= 0) g.floatingTexts.splice(i, 1); }
    for (let i = g.enemyBullets.length - 1; i >= 0; i--) { let eb = g.enemyBullets[i]; eb.x += eb.dx || 0; eb.y += eb.dy || 6; ctx.fillStyle = '#facc15'; ctx.beginPath(); ctx.arc(eb.x, eb.y, 6, 0, Math.PI * 2); ctx.fill(); if (Math.hypot(p.x - eb.x, p.y - eb.y) < p.radius + 8) { if (p.shield <= 0) { setLives(l => { if (l - 1 <= 0) { setView('GAME_OVER'); saveStats({ crates: crates + 1, highScore: Math.max(highScore, score) }); setCrates(c => c + 1); } return l - 1; }); spawnText(p.x, p.y, "HULL DAMAGE!", '#ef4444'); } g.enemyBullets.splice(i, 1); } if (eb.y > g.height + 50) g.enemyBullets.splice(i, 1); }

    requestRef.current = requestAnimationFrame(loop);
  };

  useEffect(() => {
    if (view === 'PLAYING' && !isPaused) requestRef.current = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(requestRef.current);
  }, [view, isPaused, score, bossActive, combo]); // Now safe because bossActive is defined

  const openCrate = () => { if (crates > 0) { playSfx('coin'); const reward = Math.floor(Math.random() * 50) + 15; const nC = coins + reward; const nCr = crates - 1; setCoins(nC); setCrates(nCr); saveStats({ coins: nC, crates: nCr }); alert(`CRATE UNLOCKED! FOUND ${reward} CREDITS`); } };
  const buyShip = (idx) => { const s = SHIPS[idx]; if (unlockedShips.includes(idx)) setSelectedShipIndex(idx); else if (coins >= s.price) { playSfx('coin'); const u = [...unlockedShips, idx]; const c = coins - s.price; setUnlockedShips(u); setCoins(c); setSelectedShipIndex(idx); saveStats({ coins: c, unlockedShips: u, selectedShipIndex: idx }); } };

  return (
    <div className="fixed inset-0 bg-slate-950 text-white font-sans select-none overflow-hidden">
      <canvas ref={canvasRef} className="block w-full h-full" onTouchStart={(e) => { if (e.touches[0]) gameRef.current.touchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY }; }} onTouchMove={(e) => { if (e.touches[0]) gameRef.current.touchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY }; }} onTouchEnd={() => { gameRef.current.touchPos = null; }} />
      
      {showWarning && <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-red-950/50 backdrop-blur-sm animate-pulse"><AlertTriangle size={100} className="text-red-500 mb-4" /><h2 className="text-6xl font-black italic">WARNING</h2></div>}

      {view === 'HOME' && (
        <div className="absolute inset-0 flex flex-col items-center justify-center bg-slate-900/70 backdrop-blur-md z-10 p-6">
          <button onClick={() => setSoundEnabled(!soundEnabled)} className="absolute top-6 right-6 p-3 bg-white/10 rounded-full">{soundEnabled ? <Volume2 /> : <VolumeX />}</button>
          <div className="mb-12 text-center">
             <h1 className="text-6xl font-black italic text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 via-blue-500 to-purple-600 drop-shadow-2xl tracking-tighter">COSMIC<br />GUARDIAN</h1>
             <p className="text-xs font-bold tracking-[0.5em] mt-2 uppercase text-cyan-200">BULLETPROOF ELITE</p>
          </div>
          <div className="w-full max-w-xs space-y-4">
             <button onClick={startMission} className="w-full py-5 bg-blue-600 rounded-2xl font-black text-xl flex items-center justify-center gap
